<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xpblog</title>
    <link>https://xp329486175.github.io/</link>
    <description>Recent content on xpblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-Hans</language>
    <lastBuildDate>Sat, 19 Oct 2019 14:32:37 -0700</lastBuildDate>
    
	<atom:link href="https://xp329486175.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>手机拍照基础</title>
      <link>https://xp329486175.github.io/moment/2019-10/%E6%89%8B%E6%9C%BA%E6%8B%8D%E7%85%A7%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sat, 19 Oct 2019 14:32:37 -0700</pubDate>
      
      <guid>https://xp329486175.github.io/moment/2019-10/%E6%89%8B%E6%9C%BA%E6%8B%8D%E7%85%A7%E5%9F%BA%E7%A1%80/</guid>
      <description>正确的拍照姿势 一只手握稳手机，另一只手辅助持机，并进行屏幕操作，拇指控制快门，方便调节曝光。 弄懂对焦原理 焦点，一般就是想要表达的主体。（拍背景虚化） 手机虽然会帮我们自动选择焦点，但一般情况还是建议自己确定焦点。 点击屏幕，选择焦点。 长按焦点，锁定焦点。 测光原理 拍照时，手机会自动帮我们获取一个画面明亮程度，这样的一个过程就是测光。 通常来说，当手机拍到一个很亮的场景，就会自动压低亮度。拍到一个很暗的场景</description>
    </item>
    
    <item>
      <title>git三对象commit、tree、blob</title>
      <link>https://xp329486175.github.io/blog/2019-08/git%E4%B8%89%E5%AF%B9%E8%B1%A1committreeblob/</link>
      <pubDate>Fri, 02 Aug 2019 15:29:37 -0700</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-08/git%E4%B8%89%E5%AF%B9%E8%B1%A1committreeblob/</guid>
      <description>git对象 Git 是一套内容寻址文件系统。从核心上来看不过是简单地存储键值对（key-value）。它允许插入任意类型的内容，并会返回一个键值，通过该键值可以在任何时候再取出该内容。 可以通过底层命令 hash-object 来示范这点，传一些数据给该命令，它会将数据保存在 .git 目录并返回表示这些数据的键值。 ➜ xp329486175.github.io git:(master) find .git/objects .git/objects/22 .git/objects/25 ➜ xp329486175.github.io git:(master) find .git/objects/25 -type f .git/objects/25/d9818432ffbdb20f482dbefc07b38634b9b748 .git/objects/25/1263c13a2ad0ffe6916dd8c9a28cb3e46b1442 .git/objects/25/1ee10240462a1ecf1cb7e4765a0554b4af154a .git/objects/25/5b178360d88dcb5cd9ed13b8a4ed666b632cb0 .git/objects/25/9c460600f35789e3c8df91a510f198b16e1129 .git/objects/25/25a02051c063f2ade525cda2eafc259f71e53c .git/objects/25/3a3e88518e606c1187e9b8a9cf8243c0c45280 .git/objects/25/d451b1f647ea9a5bbfed9bfd8edf3b237df0d0 git有四个常用的对象（或者称为组件）概念： tag commit tree blob 首先我们可以通过find .git/objects -type f</description>
    </item>
    
    <item>
      <title>git简析</title>
      <link>https://xp329486175.github.io/blog/2019-07/git%E7%AE%80%E6%9E%90/</link>
      <pubDate>Wed, 31 Jul 2019 20:18:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-07/git%E7%AE%80%E6%9E%90/</guid>
      <description>git简单介绍 平时经常用到git，这里就做一个简单总结。首先盗个图： 几个专有名词的意思： Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 值得注意的几个命令 1、有时候git远端仓库有某个分支，而我在gitlab上merge时，却没有看到这个分支。此时我们需要用到fetch这个命令，将远端分支同步到本地仓库。 # 同步所有分支 git fetch #同步单个分</description>
    </item>
    
    <item>
      <title>http五大特点总结</title>
      <link>https://xp329486175.github.io/blog/2019-07/http%E4%BA%94%E5%A4%A7%E7%89%B9%E7%82%B9%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 29 Jul 2019 23:19:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-07/http%E4%BA%94%E5%A4%A7%E7%89%B9%E7%82%B9%E6%80%BB%E7%BB%93/</guid>
      <description>灵活可扩展 HTTP是一个&amp;rdquo;灵活可扩展&amp;rdquo;的传输协议。 主要体现在：http可以任意添加头字段实现任意功能。 HTTP协议最初诞生的时候就比较简单，本着开放的精神只规定了报文的基本格式，比如用空格分隔单词，用换行分隔字段， “header+body”等，报文里的各个组成部分都没有做严格的语法语义限制，可以由开发者任意定制。 所以，HTTP 协议就随着互联网的发展一同成长起来了。在这个过程</description>
    </item>
    
    <item>
      <title>python基础梳理</title>
      <link>https://xp329486175.github.io/blog/2019-07/python%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/</link>
      <pubDate>Mon, 08 Jul 2019 18:21:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-07/python%E5%9F%BA%E7%A1%80%E6%A2%B3%E7%90%86/</guid>
      <description>python简介 定位 python的定位：优雅、明确、简单。 python解释器 Cpython：C语言开发。通常在命令行下运行python就是启动CPython解释器，一般是以&amp;gt;&amp;gt;&amp;gt;作提示符。 IPython：基于CPython之上的一个交互式解释器，只是在交互方式上有所增强。Python用In [序号]:作为提示符。 PyPy：P采用JIT技术，对Python代码进行动态编译（注意不是解</description>
    </item>
    
    <item>
      <title>python关键字</title>
      <link>https://xp329486175.github.io/blog/2019-07/python%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Sun, 07 Jul 2019 18:11:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-07/python%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>关键字获取 Python自带了一个keyword模块，用于检测关键字。 &amp;gt;&amp;gt;&amp;gt; import keyword &amp;gt;&amp;gt;&amp;gt; print(keyword.kwlist) [&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;async&#39;, &#39;await&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;] 关键字判断 关键字判断也是用的keyword模块。 &amp;gt;&amp;gt;&amp;gt; keyword.iskeyword(&#39;class&#39;) True &amp;gt;&amp;gt;&amp;gt; keyword.iskeyword(&#39;hello&#39;) False 关键字详解 and、or、not 分别对应逻辑判断 【与】、【或】、【非】。 with、as with、as单独没有实际意思，常与with组合使用，with...as。例如我生成一个txt文件，在里面写</description>
    </item>
    
    <item>
      <title>mac下python2和python3同时安装pip2和pip3</title>
      <link>https://xp329486175.github.io/blog/2019-07/mac%E4%B8%8Bpython2%E5%92%8Cpython3%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85pip2%E5%92%8Cpip3/</link>
      <pubDate>Mon, 01 Jul 2019 20:21:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-07/mac%E4%B8%8Bpython2%E5%92%8Cpython3%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85pip2%E5%92%8Cpip3/</guid>
      <description>序 今天使用pip安装gearman时，遇到一个坑，记录一下。 安装时，提示报错，然后发现时python版本问题。pip对应的python版本是python3.7。 ➜ member_avatar git:(master) pip -V pip 19.1.1 from /usr/local/lib/python3.7/site-packages/pip (python 3.7) 因此，我需要将我的python2，也安装一个对应的pip。然后将pip3指向python3。 安装pip2和pip3 由于mac虽然自带了python，但是却没有自带pip。所以我们需要用mac里面python自带easy</description>
    </item>
    
    <item>
      <title>mysql事务隔离级别</title>
      <link>https://xp329486175.github.io/blog/2019-06/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link>
      <pubDate>Wed, 26 Jun 2019 23:14:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid>
      <description>隔离性 提到事务，我们都知道ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）， 今天我们就来说说其中I，也就是“隔离性”。 当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、 幻读（phantom read）的问题。为了解决这些问题，我们就需要引入&amp;r</description>
    </item>
    
    <item>
      <title>程序员练级之路</title>
      <link>https://xp329486175.github.io/blog/2019-06/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BB%83%E7%BA%A7%E4%B9%8B%E8%B7%AF/</link>
      <pubDate>Tue, 25 Jun 2019 23:00:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BB%83%E7%BA%A7%E4%B9%8B%E8%B7%AF/</guid>
      <description>序 从博客搭建到今天，正好是两周了，这是第15篇blog。今天放松下不写纯技术类博文了，聊聊程序员相关话题：级别和晋升。 在程序员的职业生涯之中，都会经历一个修炼成长、打怪升级的过程。虽然我工作时间比起那些十年二十年的资深大佬来说还太少， 但也毕业四年了。这里就根据看到的一些文章和自己这四年职业生涯，还是写点感想吧。当然每个人都有自己的看法，这只是我个人或者说是个人认同的观点。 级别要分为两个方面：个人能</description>
    </item>
    
    <item>
      <title>字符编码基础</title>
      <link>https://xp329486175.github.io/blog/2019-06/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 24 Jun 2019 21:36:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80/</guid>
      <description>字符编码 我们都知道，字符串是一种数据类型。但是字符串和其他数据类型相比，比较特殊都地方就是有编码问题。 因为计算机只能处理数字。如果要处理文本，就要先把其他类型的文本转换成数字才能处理。最早的时候计算机设计为8个比特（bit）作为一个字节（Byte）， 所以一个字节能表示的最大整数就是255（二进制11111111=十进制255）。 如果需要表示更大的整数，就需要更多的字节。如果两个字节可以表示的最大整</description>
    </item>
    
    <item>
      <title>redo log和binlog</title>
      <link>https://xp329486175.github.io/blog/2019-06/redo-log%E5%92%8Cbinlog/</link>
      <pubDate>Sun, 23 Jun 2019 11:42:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/redo-log%E5%92%8Cbinlog/</guid>
      <description>序 前面我们介绍了一条查询sql的执行过程《一条SQL查询语句是如何执行的》。 那如果是一条更新sql呢？会是一个怎样的执行过程？ 其实一条更新语句与查询语句执行过程基本一样。经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。 但是它还是有差别的。差别就在redo log和binlog。 redo log和binlog 前面我们说过：mysql可以看成两块：server层和存储引擎层。 而作为mysql中最</description>
    </item>
    
    <item>
      <title>https工作原理与配置</title>
      <link>https://xp329486175.github.io/blog/2019-06/https%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sat, 22 Jun 2019 23:00:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/https%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/</guid>
      <description>https配置 在前面的一篇博客《使用nginx搭建一个简单具有反向代理功能的网站》中我们已经搭建了一个具有反向代理的网站。那如果我们要接着配置https应该怎么做呢？ 如果是自己的web网站，我们可以使用这样一个自动化脚本进行配置：Let’s Encrypt。 具体命令： #yum install python2-certbot-nginx #cerbot —nginx—nginx-server-root=/Users/xiepeng/xp/nginx/conf -d a.test.pub 这两行命令实际的</description>
    </item>
    
    <item>
      <title>最好、最坏、平均、均摊时间复杂度计算</title>
      <link>https://xp329486175.github.io/blog/2019-06/%E6%9C%80%E5%A5%BD%E6%9C%80%E5%9D%8F%E5%B9%B3%E5%9D%87%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Fri, 21 Jun 2019 22:38:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/%E6%9C%80%E5%A5%BD%E6%9C%80%E5%9D%8F%E5%B9%B3%E5%9D%87%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97/</guid>
      <description>序 上一篇博客《怎么计算时间和空间复杂度?》讲了基本的算法复杂度怎么算。但是如果我们碰到复杂一点的代码，有时候还是会不够用。 比如这一段代码： function find($arr, $n, $x) { $pos = -1; for ($i = 0; $i &amp;lt; $n; ++$i) { if ($arr[$i] == $x) { $pos = $i; break; } } return $pos; } 这段代码要实现的功能是：在一个数组$arr中，找出变量$x的位置。 因为，变量$x可以出现在任何位置。如果第一次就查找到了，就是O(1)，如果最后一次才查找到那就是O(n)。不同情况下，这段代码的时间复</description>
    </item>
    
    <item>
      <title>怎么计算时间和空间复杂度？</title>
      <link>https://xp329486175.github.io/blog/2019-06/%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
      <pubDate>Thu, 20 Jun 2019 19:20:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
      <description>序 通常大家衡量一段算法算法的好坏，一般都是用时间复杂度和空间负杂度来作考量指标。 那么如果有一段代码，我要如何计算它的时间复杂度和空间复杂度是多少呢？ 时间复杂度 大O复杂度表示法 算法的执行效率，粗略的讲，就是执行代码所需要的时间。多行代码时，所有代码执行时间等于每行代码执行时间相加。 也就是每行代码执行时间越久，总时间也就越久。即：总执行时间与每行代码的执行时间成正比。 在数学中，O表示正比的意思。所以可</description>
    </item>
    
    <item>
      <title>http请求方法梳理</title>
      <link>https://xp329486175.github.io/blog/2019-06/http%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E6%A2%B3%E7%90%86/</link>
      <pubDate>Wed, 19 Jun 2019 17:19:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/http%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E6%A2%B3%E7%90%86/</guid>
      <description>序 我们都知道HTTP的报文结构，它是由header+body构成，请求头里有请求方法和请求目标，响应头里有状态码和原因短语， 今天要说的就是请求头里的请求方法。 标准请求方法 HTTP协议里的&amp;rdquo;请求方法&amp;rdquo;是什么呢？ 请求方法就是客户端发出一个&amp;rdquo;动作指令&amp;rdquo;，要求服务器端对URI定位的资源执行这个动作。 目前HTTP/1.1规定了八种方法（单词必须大写）： GET：</description>
    </item>
    
    <item>
      <title>计算机到底是什么？</title>
      <link>https://xp329486175.github.io/blog/2019-06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Tue, 18 Jun 2019 18:26:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>序 最近迷上了一种学习方法：推导学习法。比如拿到一个名词，但是不知道它是什么。这时候大部分人就会产生疑问：xxx是什么？ 而推导学习法。会去从另一个角度去了解它：为什么它会出现？它是用来解决什么问题的？ 说的有些玄乎，但是其实在之前OAuth2的一篇博客中，我们就是用这种方法学习OAuth2的。接下来我就用这种方式推导计算机这个词。 基础架构推导 计算机，顾名思义，就是用来计算的机器。这里面核心的词就是：计</description>
    </item>
    
    <item>
      <title>一条SQL查询语句是如何执行的</title>
      <link>https://xp329486175.github.io/blog/2019-06/%E4%B8%80%E6%9D%A1sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</link>
      <pubDate>Mon, 17 Jun 2019 12:08:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/%E4%B8%80%E6%9D%A1sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</guid>
      <description>准备工作 首先我们建一张test表，里面有id、k、v这三个字段，添加三条测试数据。 id k v 1 k1 v1 2 k2 v2 3 k3 v3 我们写一个最简单的sql： SELECT * FROM test WHERE id = 1 那么在mysql的架构中，这条sql是怎么执行的呢？ Mysql逻辑架构 废话不多说，我们直接上图： 上面是一个mysql基本逻辑架构示意图。我们可以清楚的看到sql在mysql各个功能模块的执行过程。 要想执行一条查询sql。首先要经过连接器，将mysql客</description>
    </item>
    
    <item>
      <title>OAuth2协议之几种典型的OAuth Flow</title>
      <link>https://xp329486175.github.io/blog/2019-06/oauth2%E5%8D%8F%E8%AE%AE%E4%B9%8B%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84oauth-flow/</link>
      <pubDate>Sun, 16 Jun 2019 12:13:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/oauth2%E5%8D%8F%E8%AE%AE%E4%B9%8B%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84oauth-flow/</guid>
      <description>OAuth2运行流程 从上一篇文章我们知道了，OAuth2是什么，它的本质就是如何获取Token，如何使用Token。我们用一张图来总结一下OAuth2运行流程： A) 用户打开客户端以后，客户端要求用户给予授权。 B) 用户同意给予客户端授权。 C) 客户端使用上一步获得的授权，向认证服务器申请令牌。 D) 认证服务器对客户端进行认证以后，确认无误，同意发放令牌。 E) 客户端使用令牌，向资源服务器申请获取资源。 F) 资源服务器确</description>
    </item>
    
    <item>
      <title>OAuth2协议之白话OAuth2</title>
      <link>https://xp329486175.github.io/blog/2019-06/oauth2%E5%8D%8F%E8%AE%AE%E4%B9%8B%E7%99%BD%E8%AF%9Doauth2/</link>
      <pubDate>Sat, 15 Jun 2019 16:52:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/oauth2%E5%8D%8F%E8%AE%AE%E4%B9%8B%E7%99%BD%E8%AF%9Doauth2/</guid>
      <description>OAuth2协议是什么？ OAuth2通常也叫OAuth2.0。在我们日常生活中，我们常常会用微信或者QQ等账号去注册或者登陆其他应用。比如：用微信玩王者荣耀等。 这类在应用程序上，通过第三方账号授权，提供有限的用户数据的行为。就是OAuth2协议的一种最常见的使用场景。 官方术语 OAuth2是开放授权的一个标准，旨在让用户允许第三方应用去访问改用户在某服务器中的特定私有资源， 而可以不提供其在某服务器的</description>
    </item>
    
    <item>
      <title>浏览器输入网址再按下回车后，后面发生了什么</title>
      <link>https://xp329486175.github.io/blog/2019-06/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%86%8D%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%90%8E%E9%9D%A2%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</link>
      <pubDate>Fri, 14 Jun 2019 09:28:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%86%8D%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%90%8E%E9%9D%A2%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</guid>
      <description>序 在日常工作或者面试的时候，我们会经常被问到或者说需要知道。当我们在浏览器中输入一个网址的时候，后面发生了 什么？ 抓包分析 首先我们用浏览器访问127.0.0.1:8000，然后用Wireshark抓包查看整个过程。 我们可以看到浏览器用55938这个端口和服务端的8000端口，先是通过37、38、39这三个序号，完成tcp/ip三次握手，建立连接。 然后在序号54，发送了一个GET请求。55、56则是服</description>
    </item>
    
    <item>
      <title>nginx模块之动态编译</title>
      <link>https://xp329486175.github.io/blog/2019-06/nginx%E6%A8%A1%E5%9D%97%E4%B9%8B%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/</link>
      <pubDate>Thu, 13 Jun 2019 21:00:00 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/nginx%E6%A8%A1%E5%9D%97%E4%B9%8B%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/</guid>
      <description>Nginx动态编译介绍 Nginx之前是不支持动态编译的，直到2016年才支持。Nginx在1.9.11版本增加了一个重要的功能：动态模块。 给广大nginx使用者带来了巨大影响。 通过动态模块，我们可以在运行时有选择的添加第三方模块和官方模块。新的实现方式通过API模块保持尽可能的向后兼容。 静态模块 在支持动态编译之前，如果要给Nginx添加一个模块，需要将模块与源代码一起编译进Nginx二进制文件。而</description>
    </item>
    
    <item>
      <title>使用nginx搭建一个简单具有反向代理功能的网站</title>
      <link>https://xp329486175.github.io/blog/2019-06/%E4%BD%BF%E7%94%A8nginx%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%85%B7%E6%9C%89%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%8A%9F%E8%83%BD%E7%9A%84%E7%BD%91%E7%AB%99/</link>
      <pubDate>Wed, 12 Jun 2019 23:00:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/%E4%BD%BF%E7%94%A8nginx%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%85%B7%E6%9C%89%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%8A%9F%E8%83%BD%E7%9A%84%E7%BD%91%E7%AB%99/</guid>
      <description>Nginx介绍 作为一个web开发者，Nginx是最常用的web容器。 官方介绍 nginx是基于rest架构风格， 以统一资源描述符URI或者统一资源定位符URL作为沟通依据，通过HTTP协议提供各种网络服务的web服务器。 我的理解 物理上：nginx是由二进制文件、nginx.conf配置文件、access log、error log四部分组成。 逻辑上：nginx是由各种各样的模块（Modules）组成。模</description>
    </item>
    
    <item>
      <title>sql小技巧(1) order by field</title>
      <link>https://xp329486175.github.io/blog/2019-06/sql%E5%B0%8F%E6%8A%80%E5%B7%A71-order-by-field/</link>
      <pubDate>Tue, 11 Jun 2019 15:28:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/sql%E5%B0%8F%E6%8A%80%E5%B7%A71-order-by-field/</guid>
      <description>序 在工作中，遇到了一个需求，需要通过where in $condition查询， 然后查询出来的结果又需要按照$condition来排序。 此时就可以用到order by field来进行排序了。 例子 这里我以id为条件做举例。 当不排序的时候 SELECT `id`, `name` FROM rb_robot WHERE id IN ( 51, 50, 49 ) 此时返回的结果： id name 49 三号 50 四号 51 五号 当排序的时候 SELECT `id`, `name` FROM rb_robot WHERE id IN ( 51, 50, 49 ) ORDER BY FIELD( id, 51, 50, 49 ) 此时返回的结果： id name 51 五号 50 四号 49 三号</description>
    </item>
    
    <item>
      <title>《血钻》观后repo</title>
      <link>https://xp329486175.github.io/moment/2019-06/%E8%A1%80%E9%92%BB/</link>
      <pubDate>Mon, 10 Jun 2019 20:29:37 -0700</pubDate>
      
      <guid>https://xp329486175.github.io/moment/2019-06/%E8%A1%80%E9%92%BB/</guid>
      <description>《血钻》 不专业影评 昨天晚上8点多就睡着了，然后今天早上4点多醒了就睡不着了。正好看到群里有人发的618腾讯视频搞活动。 腾讯视频会员一年88。 开了一年会员，打开app看电影。还是挺期待的，之前看很多网站和影评都反馈非常好。 但是实际看下来，我却是有点失望的。不是不好看，确实是还不错。但是我并没有震撼的那种感觉， 甚至有很多地方觉得很老套，不用看就知道接下来会发生什么&amp;hellip; 可能是期待太高导致的落</description>
    </item>
    
  </channel>
</rss>