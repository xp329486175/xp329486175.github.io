<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机网络 on xpblog</title>
    <link>https://xp329486175.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
    <description>Recent content in 计算机网络 on xpblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-Hans</language>
    <lastBuildDate>Sat, 22 Jun 2019 23:00:48 +0800</lastBuildDate>
    
	<atom:link href="https://xp329486175.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>https工作原理与配置</title>
      <link>https://xp329486175.github.io/blog/2019-06/https%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sat, 22 Jun 2019 23:00:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/https%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/</guid>
      <description>https配置 在前面的一篇博客《使用nginx搭建一个简单具有反向代理功能的网站》中我们已经搭建了一个具有反向代理的网站。那如果我们要接着配置https应该怎么做呢？ 如果是自己的web网站，我们可以使用这样一个自动化脚本进行配置：Let’s Encrypt。 具体命令： #yum install python2-certbot-nginx #cerbot —nginx—nginx-server-root=/Users/xiepeng/xp/nginx/conf -d a.test.pub 这两行命令实际的</description>
    </item>
    
    <item>
      <title>http请求方法梳理</title>
      <link>https://xp329486175.github.io/blog/2019-06/http%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E6%A2%B3%E7%90%86/</link>
      <pubDate>Wed, 19 Jun 2019 17:19:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/http%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E6%A2%B3%E7%90%86/</guid>
      <description>序 我们都知道HTTP的报文结构，它是由header+body构成，请求头里有请求方法和请求目标，响应头里有状态码和原因短语， 今天要说的就是请求头里的请求方法。 标准请求方法 HTTP协议里的&amp;rdquo;请求方法&amp;rdquo;是什么呢？ 请求方法就是客户端发出一个&amp;rdquo;动作指令&amp;rdquo;，要求服务器端对URI定位的资源执行这个动作。 目前HTTP/1.1规定了八种方法（单词必须大写）： GET：</description>
    </item>
    
    <item>
      <title>浏览器输入网址再按下回车后，后面发生了什么</title>
      <link>https://xp329486175.github.io/blog/2019-06/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%86%8D%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%90%8E%E9%9D%A2%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</link>
      <pubDate>Fri, 14 Jun 2019 09:28:48 +0800</pubDate>
      
      <guid>https://xp329486175.github.io/blog/2019-06/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%86%8D%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%90%8E%E9%9D%A2%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</guid>
      <description>序 在日常工作或者面试的时候，我们会经常被问到或者说需要知道。当我们在浏览器中输入一个网址的时候，后面发生了 什么？ 抓包分析 首先我们用浏览器访问127.0.0.1:8000，然后用Wireshark抓包查看整个过程。 我们可以看到浏览器用55938这个端口和服务端的8000端口，先是通过37、38、39这三个序号，完成tcp/ip三次握手，建立连接。 然后在序号54，发送了一个GET请求。55、56则是服</description>
    </item>
    
  </channel>
</rss>